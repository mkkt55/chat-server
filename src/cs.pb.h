// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cs_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cs_2eproto;
namespace cs {
class close_door_req;
class close_door_reqDefaultTypeInternal;
extern close_door_reqDefaultTypeInternal _close_door_req_default_instance_;
class close_door_resp;
class close_door_respDefaultTypeInternal;
extern close_door_respDefaultTypeInternal _close_door_resp_default_instance_;
class create_room_req;
class create_room_reqDefaultTypeInternal;
extern create_room_reqDefaultTypeInternal _create_room_req_default_instance_;
class create_room_resp;
class create_room_respDefaultTypeInternal;
extern create_room_respDefaultTypeInternal _create_room_resp_default_instance_;
class join_room_req;
class join_room_reqDefaultTypeInternal;
extern join_room_reqDefaultTypeInternal _join_room_req_default_instance_;
class join_room_resp;
class join_room_respDefaultTypeInternal;
extern join_room_respDefaultTypeInternal _join_room_resp_default_instance_;
class login_req;
class login_reqDefaultTypeInternal;
extern login_reqDefaultTypeInternal _login_req_default_instance_;
class login_resp;
class login_respDefaultTypeInternal;
extern login_respDefaultTypeInternal _login_resp_default_instance_;
class open_door_req;
class open_door_reqDefaultTypeInternal;
extern open_door_reqDefaultTypeInternal _open_door_req_default_instance_;
class open_door_resp;
class open_door_respDefaultTypeInternal;
extern open_door_respDefaultTypeInternal _open_door_resp_default_instance_;
}  // namespace cs
PROTOBUF_NAMESPACE_OPEN
template<> ::cs::close_door_req* Arena::CreateMaybeMessage<::cs::close_door_req>(Arena*);
template<> ::cs::close_door_resp* Arena::CreateMaybeMessage<::cs::close_door_resp>(Arena*);
template<> ::cs::create_room_req* Arena::CreateMaybeMessage<::cs::create_room_req>(Arena*);
template<> ::cs::create_room_resp* Arena::CreateMaybeMessage<::cs::create_room_resp>(Arena*);
template<> ::cs::join_room_req* Arena::CreateMaybeMessage<::cs::join_room_req>(Arena*);
template<> ::cs::join_room_resp* Arena::CreateMaybeMessage<::cs::join_room_resp>(Arena*);
template<> ::cs::login_req* Arena::CreateMaybeMessage<::cs::login_req>(Arena*);
template<> ::cs::login_resp* Arena::CreateMaybeMessage<::cs::login_resp>(Arena*);
template<> ::cs::open_door_req* Arena::CreateMaybeMessage<::cs::open_door_req>(Arena*);
template<> ::cs::open_door_resp* Arena::CreateMaybeMessage<::cs::open_door_resp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace cs {

enum proto_id : int {
  login_req_id = 1,
  login_resp_id = 2,
  create_room_req_id = 3,
  create_room_resp_id = 4,
  open_door_req_id = 5,
  open_door_resp_id = 6,
  close_door_req_id = 7,
  close_door_resp_id = 8,
  join_room_req_id = 9,
  join_room_resp_id = 10
};
bool proto_id_IsValid(int value);
constexpr proto_id proto_id_MIN = login_req_id;
constexpr proto_id proto_id_MAX = join_room_resp_id;
constexpr int proto_id_ARRAYSIZE = proto_id_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* proto_id_descriptor();
template<typename T>
inline const std::string& proto_id_Name(T enum_t_value) {
  static_assert(::std::is_same<T, proto_id>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function proto_id_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    proto_id_descriptor(), enum_t_value);
}
inline bool proto_id_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, proto_id* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<proto_id>(
    proto_id_descriptor(), name, value);
}
// ===================================================================

class login_req PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cs.login_req) */ {
 public:
  inline login_req() : login_req(nullptr) {}
  virtual ~login_req();

  login_req(const login_req& from);
  login_req(login_req&& from) noexcept
    : login_req() {
    *this = ::std::move(from);
  }

  inline login_req& operator=(const login_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline login_req& operator=(login_req&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const login_req& default_instance();

  static inline const login_req* internal_default_instance() {
    return reinterpret_cast<const login_req*>(
               &_login_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(login_req& a, login_req& b) {
    a.Swap(&b);
  }
  inline void Swap(login_req* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(login_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline login_req* New() const final {
    return CreateMaybeMessage<login_req>(nullptr);
  }

  login_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<login_req>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const login_req& from);
  void MergeFrom(const login_req& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(login_req* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cs.login_req";
  }
  protected:
  explicit login_req(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cs_2eproto);
    return ::descriptor_table_cs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required .cs.proto_id id = 1 [default = login_req_id];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::cs::proto_id id() const;
  void set_id(::cs::proto_id value);
  private:
  ::cs::proto_id _internal_id() const;
  void _internal_set_id(::cs::proto_id value);
  public:

  // @@protoc_insertion_point(class_scope:cs.login_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int id_;
  friend struct ::TableStruct_cs_2eproto;
};
// -------------------------------------------------------------------

class login_resp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cs.login_resp) */ {
 public:
  inline login_resp() : login_resp(nullptr) {}
  virtual ~login_resp();

  login_resp(const login_resp& from);
  login_resp(login_resp&& from) noexcept
    : login_resp() {
    *this = ::std::move(from);
  }

  inline login_resp& operator=(const login_resp& from) {
    CopyFrom(from);
    return *this;
  }
  inline login_resp& operator=(login_resp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const login_resp& default_instance();

  static inline const login_resp* internal_default_instance() {
    return reinterpret_cast<const login_resp*>(
               &_login_resp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(login_resp& a, login_resp& b) {
    a.Swap(&b);
  }
  inline void Swap(login_resp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(login_resp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline login_resp* New() const final {
    return CreateMaybeMessage<login_resp>(nullptr);
  }

  login_resp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<login_resp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const login_resp& from);
  void MergeFrom(const login_resp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(login_resp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cs.login_resp";
  }
  protected:
  explicit login_resp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cs_2eproto);
    return ::descriptor_table_cs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required .cs.proto_id id = 1 [default = login_resp_id];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::cs::proto_id id() const;
  void set_id(::cs::proto_id value);
  private:
  ::cs::proto_id _internal_id() const;
  void _internal_set_id(::cs::proto_id value);
  public:

  // @@protoc_insertion_point(class_scope:cs.login_resp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int id_;
  friend struct ::TableStruct_cs_2eproto;
};
// -------------------------------------------------------------------

class create_room_req PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cs.create_room_req) */ {
 public:
  inline create_room_req() : create_room_req(nullptr) {}
  virtual ~create_room_req();

  create_room_req(const create_room_req& from);
  create_room_req(create_room_req&& from) noexcept
    : create_room_req() {
    *this = ::std::move(from);
  }

  inline create_room_req& operator=(const create_room_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline create_room_req& operator=(create_room_req&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const create_room_req& default_instance();

  static inline const create_room_req* internal_default_instance() {
    return reinterpret_cast<const create_room_req*>(
               &_create_room_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(create_room_req& a, create_room_req& b) {
    a.Swap(&b);
  }
  inline void Swap(create_room_req* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(create_room_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline create_room_req* New() const final {
    return CreateMaybeMessage<create_room_req>(nullptr);
  }

  create_room_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<create_room_req>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const create_room_req& from);
  void MergeFrom(const create_room_req& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(create_room_req* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cs.create_room_req";
  }
  protected:
  explicit create_room_req(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cs_2eproto);
    return ::descriptor_table_cs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required .cs.proto_id id = 1 [default = create_room_req_id];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::cs::proto_id id() const;
  void set_id(::cs::proto_id value);
  private:
  ::cs::proto_id _internal_id() const;
  void _internal_set_id(::cs::proto_id value);
  public:

  // @@protoc_insertion_point(class_scope:cs.create_room_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int id_;
  friend struct ::TableStruct_cs_2eproto;
};
// -------------------------------------------------------------------

class create_room_resp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cs.create_room_resp) */ {
 public:
  inline create_room_resp() : create_room_resp(nullptr) {}
  virtual ~create_room_resp();

  create_room_resp(const create_room_resp& from);
  create_room_resp(create_room_resp&& from) noexcept
    : create_room_resp() {
    *this = ::std::move(from);
  }

  inline create_room_resp& operator=(const create_room_resp& from) {
    CopyFrom(from);
    return *this;
  }
  inline create_room_resp& operator=(create_room_resp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const create_room_resp& default_instance();

  static inline const create_room_resp* internal_default_instance() {
    return reinterpret_cast<const create_room_resp*>(
               &_create_room_resp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(create_room_resp& a, create_room_resp& b) {
    a.Swap(&b);
  }
  inline void Swap(create_room_resp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(create_room_resp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline create_room_resp* New() const final {
    return CreateMaybeMessage<create_room_resp>(nullptr);
  }

  create_room_resp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<create_room_resp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const create_room_resp& from);
  void MergeFrom(const create_room_resp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(create_room_resp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cs.create_room_resp";
  }
  protected:
  explicit create_room_resp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cs_2eproto);
    return ::descriptor_table_cs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required .cs.proto_id id = 1 [default = create_room_resp_id];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::cs::proto_id id() const;
  void set_id(::cs::proto_id value);
  private:
  ::cs::proto_id _internal_id() const;
  void _internal_set_id(::cs::proto_id value);
  public:

  // @@protoc_insertion_point(class_scope:cs.create_room_resp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int id_;
  friend struct ::TableStruct_cs_2eproto;
};
// -------------------------------------------------------------------

class open_door_req PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cs.open_door_req) */ {
 public:
  inline open_door_req() : open_door_req(nullptr) {}
  virtual ~open_door_req();

  open_door_req(const open_door_req& from);
  open_door_req(open_door_req&& from) noexcept
    : open_door_req() {
    *this = ::std::move(from);
  }

  inline open_door_req& operator=(const open_door_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline open_door_req& operator=(open_door_req&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const open_door_req& default_instance();

  static inline const open_door_req* internal_default_instance() {
    return reinterpret_cast<const open_door_req*>(
               &_open_door_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(open_door_req& a, open_door_req& b) {
    a.Swap(&b);
  }
  inline void Swap(open_door_req* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(open_door_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline open_door_req* New() const final {
    return CreateMaybeMessage<open_door_req>(nullptr);
  }

  open_door_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<open_door_req>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const open_door_req& from);
  void MergeFrom(const open_door_req& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(open_door_req* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cs.open_door_req";
  }
  protected:
  explicit open_door_req(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cs_2eproto);
    return ::descriptor_table_cs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required .cs.proto_id id = 1 [default = open_door_req_id];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::cs::proto_id id() const;
  void set_id(::cs::proto_id value);
  private:
  ::cs::proto_id _internal_id() const;
  void _internal_set_id(::cs::proto_id value);
  public:

  // @@protoc_insertion_point(class_scope:cs.open_door_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int id_;
  friend struct ::TableStruct_cs_2eproto;
};
// -------------------------------------------------------------------

class open_door_resp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cs.open_door_resp) */ {
 public:
  inline open_door_resp() : open_door_resp(nullptr) {}
  virtual ~open_door_resp();

  open_door_resp(const open_door_resp& from);
  open_door_resp(open_door_resp&& from) noexcept
    : open_door_resp() {
    *this = ::std::move(from);
  }

  inline open_door_resp& operator=(const open_door_resp& from) {
    CopyFrom(from);
    return *this;
  }
  inline open_door_resp& operator=(open_door_resp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const open_door_resp& default_instance();

  static inline const open_door_resp* internal_default_instance() {
    return reinterpret_cast<const open_door_resp*>(
               &_open_door_resp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(open_door_resp& a, open_door_resp& b) {
    a.Swap(&b);
  }
  inline void Swap(open_door_resp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(open_door_resp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline open_door_resp* New() const final {
    return CreateMaybeMessage<open_door_resp>(nullptr);
  }

  open_door_resp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<open_door_resp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const open_door_resp& from);
  void MergeFrom(const open_door_resp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(open_door_resp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cs.open_door_resp";
  }
  protected:
  explicit open_door_resp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cs_2eproto);
    return ::descriptor_table_cs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required .cs.proto_id id = 1 [default = open_door_resp_id];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::cs::proto_id id() const;
  void set_id(::cs::proto_id value);
  private:
  ::cs::proto_id _internal_id() const;
  void _internal_set_id(::cs::proto_id value);
  public:

  // @@protoc_insertion_point(class_scope:cs.open_door_resp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int id_;
  friend struct ::TableStruct_cs_2eproto;
};
// -------------------------------------------------------------------

class close_door_req PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cs.close_door_req) */ {
 public:
  inline close_door_req() : close_door_req(nullptr) {}
  virtual ~close_door_req();

  close_door_req(const close_door_req& from);
  close_door_req(close_door_req&& from) noexcept
    : close_door_req() {
    *this = ::std::move(from);
  }

  inline close_door_req& operator=(const close_door_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline close_door_req& operator=(close_door_req&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const close_door_req& default_instance();

  static inline const close_door_req* internal_default_instance() {
    return reinterpret_cast<const close_door_req*>(
               &_close_door_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(close_door_req& a, close_door_req& b) {
    a.Swap(&b);
  }
  inline void Swap(close_door_req* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(close_door_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline close_door_req* New() const final {
    return CreateMaybeMessage<close_door_req>(nullptr);
  }

  close_door_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<close_door_req>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const close_door_req& from);
  void MergeFrom(const close_door_req& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(close_door_req* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cs.close_door_req";
  }
  protected:
  explicit close_door_req(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cs_2eproto);
    return ::descriptor_table_cs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required .cs.proto_id id = 1 [default = close_door_req_id];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::cs::proto_id id() const;
  void set_id(::cs::proto_id value);
  private:
  ::cs::proto_id _internal_id() const;
  void _internal_set_id(::cs::proto_id value);
  public:

  // @@protoc_insertion_point(class_scope:cs.close_door_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int id_;
  friend struct ::TableStruct_cs_2eproto;
};
// -------------------------------------------------------------------

class close_door_resp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cs.close_door_resp) */ {
 public:
  inline close_door_resp() : close_door_resp(nullptr) {}
  virtual ~close_door_resp();

  close_door_resp(const close_door_resp& from);
  close_door_resp(close_door_resp&& from) noexcept
    : close_door_resp() {
    *this = ::std::move(from);
  }

  inline close_door_resp& operator=(const close_door_resp& from) {
    CopyFrom(from);
    return *this;
  }
  inline close_door_resp& operator=(close_door_resp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const close_door_resp& default_instance();

  static inline const close_door_resp* internal_default_instance() {
    return reinterpret_cast<const close_door_resp*>(
               &_close_door_resp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(close_door_resp& a, close_door_resp& b) {
    a.Swap(&b);
  }
  inline void Swap(close_door_resp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(close_door_resp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline close_door_resp* New() const final {
    return CreateMaybeMessage<close_door_resp>(nullptr);
  }

  close_door_resp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<close_door_resp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const close_door_resp& from);
  void MergeFrom(const close_door_resp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(close_door_resp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cs.close_door_resp";
  }
  protected:
  explicit close_door_resp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cs_2eproto);
    return ::descriptor_table_cs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required .cs.proto_id id = 1 [default = close_door_resp_id];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::cs::proto_id id() const;
  void set_id(::cs::proto_id value);
  private:
  ::cs::proto_id _internal_id() const;
  void _internal_set_id(::cs::proto_id value);
  public:

  // @@protoc_insertion_point(class_scope:cs.close_door_resp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int id_;
  friend struct ::TableStruct_cs_2eproto;
};
// -------------------------------------------------------------------

class join_room_req PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cs.join_room_req) */ {
 public:
  inline join_room_req() : join_room_req(nullptr) {}
  virtual ~join_room_req();

  join_room_req(const join_room_req& from);
  join_room_req(join_room_req&& from) noexcept
    : join_room_req() {
    *this = ::std::move(from);
  }

  inline join_room_req& operator=(const join_room_req& from) {
    CopyFrom(from);
    return *this;
  }
  inline join_room_req& operator=(join_room_req&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const join_room_req& default_instance();

  static inline const join_room_req* internal_default_instance() {
    return reinterpret_cast<const join_room_req*>(
               &_join_room_req_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(join_room_req& a, join_room_req& b) {
    a.Swap(&b);
  }
  inline void Swap(join_room_req* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(join_room_req* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline join_room_req* New() const final {
    return CreateMaybeMessage<join_room_req>(nullptr);
  }

  join_room_req* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<join_room_req>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const join_room_req& from);
  void MergeFrom(const join_room_req& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(join_room_req* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cs.join_room_req";
  }
  protected:
  explicit join_room_req(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cs_2eproto);
    return ::descriptor_table_cs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required .cs.proto_id id = 1 [default = join_room_req_id];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::cs::proto_id id() const;
  void set_id(::cs::proto_id value);
  private:
  ::cs::proto_id _internal_id() const;
  void _internal_set_id(::cs::proto_id value);
  public:

  // @@protoc_insertion_point(class_scope:cs.join_room_req)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int id_;
  friend struct ::TableStruct_cs_2eproto;
};
// -------------------------------------------------------------------

class join_room_resp PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cs.join_room_resp) */ {
 public:
  inline join_room_resp() : join_room_resp(nullptr) {}
  virtual ~join_room_resp();

  join_room_resp(const join_room_resp& from);
  join_room_resp(join_room_resp&& from) noexcept
    : join_room_resp() {
    *this = ::std::move(from);
  }

  inline join_room_resp& operator=(const join_room_resp& from) {
    CopyFrom(from);
    return *this;
  }
  inline join_room_resp& operator=(join_room_resp&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const join_room_resp& default_instance();

  static inline const join_room_resp* internal_default_instance() {
    return reinterpret_cast<const join_room_resp*>(
               &_join_room_resp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(join_room_resp& a, join_room_resp& b) {
    a.Swap(&b);
  }
  inline void Swap(join_room_resp* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(join_room_resp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline join_room_resp* New() const final {
    return CreateMaybeMessage<join_room_resp>(nullptr);
  }

  join_room_resp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<join_room_resp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const join_room_resp& from);
  void MergeFrom(const join_room_resp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(join_room_resp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "cs.join_room_resp";
  }
  protected:
  explicit join_room_resp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_cs_2eproto);
    return ::descriptor_table_cs_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // required .cs.proto_id id = 1 [default = join_room_resp_id];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::cs::proto_id id() const;
  void set_id(::cs::proto_id value);
  private:
  ::cs::proto_id _internal_id() const;
  void _internal_set_id(::cs::proto_id value);
  public:

  // @@protoc_insertion_point(class_scope:cs.join_room_resp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int id_;
  friend struct ::TableStruct_cs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// login_req

// required .cs.proto_id id = 1 [default = login_req_id];
inline bool login_req::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool login_req::has_id() const {
  return _internal_has_id();
}
inline void login_req::clear_id() {
  id_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::cs::proto_id login_req::_internal_id() const {
  return static_cast< ::cs::proto_id >(id_);
}
inline ::cs::proto_id login_req::id() const {
  // @@protoc_insertion_point(field_get:cs.login_req.id)
  return _internal_id();
}
inline void login_req::_internal_set_id(::cs::proto_id value) {
  assert(::cs::proto_id_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void login_req::set_id(::cs::proto_id value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cs.login_req.id)
}

// -------------------------------------------------------------------

// login_resp

// required .cs.proto_id id = 1 [default = login_resp_id];
inline bool login_resp::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool login_resp::has_id() const {
  return _internal_has_id();
}
inline void login_resp::clear_id() {
  id_ = 2;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::cs::proto_id login_resp::_internal_id() const {
  return static_cast< ::cs::proto_id >(id_);
}
inline ::cs::proto_id login_resp::id() const {
  // @@protoc_insertion_point(field_get:cs.login_resp.id)
  return _internal_id();
}
inline void login_resp::_internal_set_id(::cs::proto_id value) {
  assert(::cs::proto_id_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void login_resp::set_id(::cs::proto_id value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cs.login_resp.id)
}

// -------------------------------------------------------------------

// create_room_req

// required .cs.proto_id id = 1 [default = create_room_req_id];
inline bool create_room_req::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool create_room_req::has_id() const {
  return _internal_has_id();
}
inline void create_room_req::clear_id() {
  id_ = 3;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::cs::proto_id create_room_req::_internal_id() const {
  return static_cast< ::cs::proto_id >(id_);
}
inline ::cs::proto_id create_room_req::id() const {
  // @@protoc_insertion_point(field_get:cs.create_room_req.id)
  return _internal_id();
}
inline void create_room_req::_internal_set_id(::cs::proto_id value) {
  assert(::cs::proto_id_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void create_room_req::set_id(::cs::proto_id value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cs.create_room_req.id)
}

// -------------------------------------------------------------------

// create_room_resp

// required .cs.proto_id id = 1 [default = create_room_resp_id];
inline bool create_room_resp::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool create_room_resp::has_id() const {
  return _internal_has_id();
}
inline void create_room_resp::clear_id() {
  id_ = 4;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::cs::proto_id create_room_resp::_internal_id() const {
  return static_cast< ::cs::proto_id >(id_);
}
inline ::cs::proto_id create_room_resp::id() const {
  // @@protoc_insertion_point(field_get:cs.create_room_resp.id)
  return _internal_id();
}
inline void create_room_resp::_internal_set_id(::cs::proto_id value) {
  assert(::cs::proto_id_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void create_room_resp::set_id(::cs::proto_id value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cs.create_room_resp.id)
}

// -------------------------------------------------------------------

// open_door_req

// required .cs.proto_id id = 1 [default = open_door_req_id];
inline bool open_door_req::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool open_door_req::has_id() const {
  return _internal_has_id();
}
inline void open_door_req::clear_id() {
  id_ = 5;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::cs::proto_id open_door_req::_internal_id() const {
  return static_cast< ::cs::proto_id >(id_);
}
inline ::cs::proto_id open_door_req::id() const {
  // @@protoc_insertion_point(field_get:cs.open_door_req.id)
  return _internal_id();
}
inline void open_door_req::_internal_set_id(::cs::proto_id value) {
  assert(::cs::proto_id_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void open_door_req::set_id(::cs::proto_id value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cs.open_door_req.id)
}

// -------------------------------------------------------------------

// open_door_resp

// required .cs.proto_id id = 1 [default = open_door_resp_id];
inline bool open_door_resp::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool open_door_resp::has_id() const {
  return _internal_has_id();
}
inline void open_door_resp::clear_id() {
  id_ = 6;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::cs::proto_id open_door_resp::_internal_id() const {
  return static_cast< ::cs::proto_id >(id_);
}
inline ::cs::proto_id open_door_resp::id() const {
  // @@protoc_insertion_point(field_get:cs.open_door_resp.id)
  return _internal_id();
}
inline void open_door_resp::_internal_set_id(::cs::proto_id value) {
  assert(::cs::proto_id_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void open_door_resp::set_id(::cs::proto_id value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cs.open_door_resp.id)
}

// -------------------------------------------------------------------

// close_door_req

// required .cs.proto_id id = 1 [default = close_door_req_id];
inline bool close_door_req::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool close_door_req::has_id() const {
  return _internal_has_id();
}
inline void close_door_req::clear_id() {
  id_ = 7;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::cs::proto_id close_door_req::_internal_id() const {
  return static_cast< ::cs::proto_id >(id_);
}
inline ::cs::proto_id close_door_req::id() const {
  // @@protoc_insertion_point(field_get:cs.close_door_req.id)
  return _internal_id();
}
inline void close_door_req::_internal_set_id(::cs::proto_id value) {
  assert(::cs::proto_id_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void close_door_req::set_id(::cs::proto_id value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cs.close_door_req.id)
}

// -------------------------------------------------------------------

// close_door_resp

// required .cs.proto_id id = 1 [default = close_door_resp_id];
inline bool close_door_resp::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool close_door_resp::has_id() const {
  return _internal_has_id();
}
inline void close_door_resp::clear_id() {
  id_ = 8;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::cs::proto_id close_door_resp::_internal_id() const {
  return static_cast< ::cs::proto_id >(id_);
}
inline ::cs::proto_id close_door_resp::id() const {
  // @@protoc_insertion_point(field_get:cs.close_door_resp.id)
  return _internal_id();
}
inline void close_door_resp::_internal_set_id(::cs::proto_id value) {
  assert(::cs::proto_id_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void close_door_resp::set_id(::cs::proto_id value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cs.close_door_resp.id)
}

// -------------------------------------------------------------------

// join_room_req

// required .cs.proto_id id = 1 [default = join_room_req_id];
inline bool join_room_req::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool join_room_req::has_id() const {
  return _internal_has_id();
}
inline void join_room_req::clear_id() {
  id_ = 9;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::cs::proto_id join_room_req::_internal_id() const {
  return static_cast< ::cs::proto_id >(id_);
}
inline ::cs::proto_id join_room_req::id() const {
  // @@protoc_insertion_point(field_get:cs.join_room_req.id)
  return _internal_id();
}
inline void join_room_req::_internal_set_id(::cs::proto_id value) {
  assert(::cs::proto_id_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void join_room_req::set_id(::cs::proto_id value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cs.join_room_req.id)
}

// -------------------------------------------------------------------

// join_room_resp

// required .cs.proto_id id = 1 [default = join_room_resp_id];
inline bool join_room_resp::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool join_room_resp::has_id() const {
  return _internal_has_id();
}
inline void join_room_resp::clear_id() {
  id_ = 10;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::cs::proto_id join_room_resp::_internal_id() const {
  return static_cast< ::cs::proto_id >(id_);
}
inline ::cs::proto_id join_room_resp::id() const {
  // @@protoc_insertion_point(field_get:cs.join_room_resp.id)
  return _internal_id();
}
inline void join_room_resp::_internal_set_id(::cs::proto_id value) {
  assert(::cs::proto_id_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void join_room_resp::set_id(::cs::proto_id value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:cs.join_room_resp.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::cs::proto_id> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cs::proto_id>() {
  return ::cs::proto_id_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cs_2eproto
